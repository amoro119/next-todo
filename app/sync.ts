// app/sync.ts
import { PGlite } from '@electric-sql/pglite'
import { PGliteWithLive } from '@electric-sql/pglite/live'
import { PGliteWithSync } from '@electric-sql/pglite-sync'
import { postInitialSync } from '../db/migrations-client'
import { useEffect, useState } from 'react'
import { ShapeStream, Shape } from '@electric-sql/client';

type SyncStatus = 'initial-sync' | 'done' | 'error'

type PGliteWithExtensions = PGliteWithLive & PGliteWithSync

// --- ËÆ§ËØÅÈÄªËæë ---
let cachedElectricToken: string | null = null;

export function invalidateElectricToken() {
  console.log("Invalidating cached Electric token.");
  cachedElectricToken = null;
}

async function getElectricToken(): Promise<string> {
  if (cachedElectricToken) {
    return cachedElectricToken;
  }

  try {
    console.log("Fetching new ElectricSQL auth token from token-issuer function...");
    
    const tokenIssuerUrl = process.env.NEXT_PUBLIC_TOKEN_ISSUER_URL;
    if (!tokenIssuerUrl) {
      throw new Error("NEXT_PUBLIC_TOKEN_ISSUER_URL is not set.");
    }

    const response = await fetch(tokenIssuerUrl);
    if (!response.ok) {
      throw new Error(`Ëé∑ÂèñElectric‰ª§ÁâåÂ§±Ë¥•: ${response.status} ${response.statusText}`);
    }
    const { token } = await response.json();
    if (!token) {
      throw new Error('Âú®ÂìçÂ∫î‰∏≠Êú™ÊâæÂà∞‰ª§Áâå');
    }
    cachedElectricToken = token;
    return token;
  } catch (error) {
    console.error("Ëé∑ÂèñElectric‰ª§ÁâåÊó∂ÂèëÁîü‰∏•ÈáçÈîôËØØ:", error);
    invalidateElectricToken();
    throw new Error(`Êó†Ê≥ïËé∑ÂèñËÆ§ËØÅ‰ª§Áâå: ${error instanceof Error ? error.message : String(error)}`);
  }
}

export async function startSync(pg: PGliteWithExtensions) {
  console.log('Starting ElectricSQL sync...')
  updateSyncStatus('initial-sync', 'Starting sync...')
  
  try {
    // Ëé∑ÂèñËÆ§ËØÅ‰ª§Áâå
    console.log("Ê≠£Âú®Ëé∑ÂèñÂêåÊ≠•ËÆ§ËØÅ‰ª§Áâå...");
    await getElectricToken(); 
    if (!cachedElectricToken) {
      throw new Error("ËÆ§ËØÅÂ§±Ë¥•ÔºöÊú™ËÉΩËé∑ÂèñÂà∞ÊúâÊïàÁöÑÂêåÊ≠•‰ª§Áâå„ÄÇ");
    }
    console.log("ËÆ§ËØÅÊàêÂäüÔºå‰ª§ÁâåÂ∑≤ÁºìÂ≠ò„ÄÇ");

    // ÂàùÂßãÂåñElectricSQLÁ≥ªÁªüË°®
    console.log('Initializing ElectricSQL system tables...')
    await initializeElectricSystemTables(pg)
    
    // Ê£ÄÊü•Êú¨Âú∞ÊòØÂê¶È¶ñÊ¨°ÂêåÊ≠•ÔºàÊó†Êï∞ÊçÆÊó∂ÊâçÊ∏ÖÁêÜËÆ¢ÈòÖÔºâ
    const listsCountRes = await pg.query('SELECT COUNT(*) as count FROM lists');
    const todosCountRes = await pg.query('SELECT COUNT(*) as count FROM todos');
    const listsCount = Number((listsCountRes.rows[0] as { count: string | number })?.count || 0);
    const todosCount = Number((todosCountRes.rows[0] as { count: string | number })?.count || 0);
    if (listsCount === 0 && todosCount === 0) {
      // ‰ªÖÈ¶ñÊ¨°ÂêåÊ≠•Êó∂Ê∏ÖÁêÜÊóßÁöÑÂêåÊ≠•ËÆ¢ÈòÖ
      console.log('È¶ñÊ¨°ÂêåÊ≠•ÔºåÊ∏ÖÁêÜÊóßÁöÑÂêåÊ≠•ËÆ¢ÈòÖ...')
      await cleanupOldSubscriptions(pg)
    } else {
      console.log('Êú¨Âú∞Â∑≤ÊúâÊï∞ÊçÆÔºåË∑≥ËøáËÆ¢ÈòÖÊ∏ÖÁêÜ')
    }
    
    // ÂêØÂä®ÈùûÁ†¥ÂùèÊÄßÁöÑÂèåÂêëÂêåÊ≠•
    console.log('Starting non-destructive bidirectional sync...')
    await startBidirectionalSync(pg)
  } catch (error) {
    console.error('Sync failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'ÂêåÊ≠•Â§±Ë¥•Ôºå‰ΩÜÂ∫îÁî®‰ªçÂèØ‰ΩøÁî®';
    if (errorMessage.includes('ËÆ§ËØÅÂ§±Ë¥•') || errorMessage.includes('ËÆ§ËØÅ‰ª§Áâå')) {
      updateSyncStatus('error', 'ËÆ§ËØÅÂ§±Ë¥•ÔºåÊó†Ê≥ïÂêåÊ≠•Êï∞ÊçÆ');
    } else {
      updateSyncStatus('error', 'ÂêåÊ≠•Â§±Ë¥•Ôºå‰ΩÜÂ∫îÁî®‰ªçÂèØ‰ΩøÁî®');
    }
  }
}

async function initializeElectricSystemTables(pg: PGliteWithExtensions) {
  console.log('Waiting for ElectricSQL to initialize system tables...')
  
  // Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥ËÆ©ElectricSQLÂàùÂßãÂåñ
  await new Promise(resolve => setTimeout(resolve, 2000))
  
  // Â∞ùËØïÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊü•ËØ¢Êù•Ëß¶ÂèëElectricSQLÁ≥ªÁªüË°®ÂàùÂßãÂåñ
  try {
    await pg.query('SELECT 1')
    console.log('ElectricSQL system tables should be initialized')
  } catch {
    console.log('ElectricSQL still initializing, continuing...')
  }
  
  // ÂÜçÁ≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥Á°Æ‰øùÁ≥ªÁªüË°®ÂàõÂª∫ÂÆåÊàê
  await new Promise(resolve => setTimeout(resolve, 1000))
}

async function cleanupOldSubscriptions(pg: PGliteWithExtensions) {
  try {
    console.log('Cleaning up old sync subscriptions...')
    
    // Âè™Ê∏ÖÁêÜÊóßÁöÑÂêåÊ≠•ËÆ¢ÈòÖÔºå‰∏çÊ∏ÖÁ©∫Êï∞ÊçÆ
    try {
      await pg.sync.deleteSubscription('lists')
      await pg.sync.deleteSubscription('todos')
      await pg.sync.deleteSubscription('meta')
      console.log('Deleted old sync subscriptions')
    } catch (error) {
      console.log('No old subscriptions to delete or error:', error instanceof Error ? error.message : String(error))
    }
    
    // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊó∂Èó¥Á°Æ‰øùËÆ¢ÈòÖÂà†Èô§ÂÆåÊàê
    await new Promise(resolve => setTimeout(resolve, 100))
    
    console.log('Old subscriptions cleanup completed')
    
  } catch (error) {
    console.log('Cleanup old subscriptions error:', error)
  }
}

async function startBidirectionalSync(pg: PGliteWithExtensions) {
  const shapes = [
    {
      name: 'lists',
      columns: ['id', 'name', 'sort_order', 'is_hidden', 'modified']
    },
    {
      name: 'todos',
      columns: ['id', 'title', 'completed', 'deleted', 'sort_order', 'due_date', 'content', 'tags', 'priority', 'created_time', 'completed_time', 'start_date', 'list_id']
    }
  ];
  const electricProxyUrl = process.env.NEXT_PUBLIC_ELECTRIC_PROXY_URL;
  if (!electricProxyUrl) {
    throw new Error("NEXT_PUBLIC_ELECTRIC_PROXY_URL is not set.");
  }
  if (!cachedElectricToken) {
    throw new Error("Authentication token is not available for sync.");
  }

  for (const shapeDef of shapes) {
    const { name: shapeName, columns } = shapeDef;
    // 1. ÂàõÂª∫ ShapeStream
    const stream = new ShapeStream({
      url: `${electricProxyUrl}/v1/shape`,
      params: {
        table: shapeName,
        columns: columns
      },
      headers: {
        'Authorization': `Bearer ${cachedElectricToken}`
      }
    });
    // 2. ÂàõÂª∫ Shape ÂØπË±°
    const shape = new Shape(stream);
    // 3. Á≠âÂæÖÂàùÂßãÂêåÊ≠•ÂÆåÊàê
    console.log('ÂàõÂª∫ ShapeStream...');
    console.log(shape);
    console.log('Á≠âÂæÖ shape.rows...');
    const rows = await shape.rows;
    console.log('shape.rows Â∑≤ËøîÂõû:', rows.length);
    // 4. ÂÜôÂÖ•Êú¨Âú∞Êï∞ÊçÆÂ∫ì
    // for (const row of rows) {
    //   if (shapeName === 'lists') {
    //     await pg.query(
    //       `INSERT INTO lists (id, name, sort_order, is_hidden, modified) VALUES ($1, $2, $3, $4, $5)
    //         ON CONFLICT(id) DO UPDATE SET name = $2, sort_order = $3, is_hidden = $4, modified = $5`,
    //       [
    //         row.id ?? null,
    //         row.name ?? null,
    //         row.sort_order ?? 0,
    //         row.is_hidden ?? false,
    //         row.modified ?? null
    //       ]
    //     );
    //   } else if (shapeName === 'todos') {
    //     await pg.query(
    //       `INSERT INTO todos (id, title, completed, deleted, sort_order, due_date, content, tags, priority, created_time, completed_time, start_date, list_id)
    //         VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)
    //         ON CONFLICT(id) DO UPDATE SET title=$2, completed=$3, deleted=$4, sort_order=$5, due_date=$6, content=$7, tags=$8, priority=$9, created_time=$10, completed_time=$11, start_date=$12, list_id=$13`,
    //       [
    //         row.id ?? null,
    //         row.title ?? null,
    //         row.completed ?? false,
    //         row.deleted ?? false,
    //         row.sort_order ?? 0,
    //         row.due_date ?? null,
    //         row.content ?? null,
    //         row.tags ?? null,
    //         row.priority ?? 0,
    //         row.created_time ?? null,
    //         row.completed_time ?? null,
    //         row.start_date ?? null,
    //         row.list_id ?? null
    //       ]
    //     );
    //   }
    // }
    console.log(`üì• ${shapeName} ÂàùÂßãÂêåÊ≠•ÂÆåÊàêÔºåÂ∑≤ÂÜôÂÖ•Êú¨Âú∞`);

    // 5. ÁõëÂê¨ shape Êï∞ÊçÆÂèòÂåñÔºåÂÆûÊó∂ÂÜôÂÖ•Êú¨Âú∞
    stream.subscribe(
      (messages) => {
        (async () => {
          console.log(messages)
          for (const msg of messages) {
            if (!('value' in msg)) continue; // Ë∑≥Ëøá control Ê∂àÊÅØ
            const row = msg.value;
            if (shapeName === 'lists') {
              await pg.query(
                `INSERT INTO lists (id, name, sort_order, is_hidden, modified) VALUES ($1, $2, $3, $4, $5)
                  ON CONFLICT(id) DO UPDATE SET name = $2, sort_order = $3, is_hidden = $4, modified = $5`,
                [
                  row.id ?? null,
                  row.name ?? null,
                  row.sort_order ?? 0,
                  row.is_hidden ?? false,
                  row.modified ?? null
                ]
              );
            } else if (shapeName === 'todos') {
              await pg.query(
                `INSERT INTO todos (id, title, completed, deleted, sort_order, due_date, content, tags, priority, created_time, completed_time, start_date, list_id)
                  VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)
                  ON CONFLICT(id) DO UPDATE SET title=$2, completed=$3, deleted=$4, sort_order=$5, due_date=$6, content=$7, tags=$8, priority=$9, created_time=$10, completed_time=$11, start_date=$12, list_id=$13`,
                [
                  row.id ?? null,
                  row.title ?? null,
                  row.completed ?? false,
                  row.deleted ?? false,
                  row.sort_order ?? 0,
                  row.due_date ?? null,
                  row.content ?? null,
                  row.tags ?? null,
                  row.priority ?? 0,
                  row.created_time ?? null,
                  row.completed_time ?? null,
                  row.start_date ?? null,
                  row.list_id ?? null
                ]
              );
            }
          }
          console.log(`üîÑ ${shapeName} ÂÆûÊó∂ÂèòÊõ¥Â∑≤ÂêåÊ≠•Âà∞Êú¨Âú∞`);
        })();
      },
      (error) => {
        // Get notified about errors
        console.error('Error in subscription:', error)
      }
    )
  }

  // Êú¨Âú∞ select Ê†°È™å
  for (const shapeDef of shapes) {
    const shapeName = shapeDef.name;
    try {
      const result = await pg.query(`SELECT COUNT(*) as count FROM ${shapeName}`);
      const count = (result.rows[0] as { count: string }).count;
      console.log(`üìä ${shapeName} ÂêåÊ≠•ÂêéËÆ∞ÂΩïÊï∞: ${count} Êù°`);
    } catch (error) {
      console.error(`‚ùå È™åËØÅ ${shapeName} Â§±Ë¥•:`, error);
    }
  }

  if (!initialSyncDone) {
    initialSyncDone = true;
    updateSyncStatus('initial-sync', 'Creating indexes...');
    await postInitialSync(pg as unknown as PGlite);
    updateSyncStatus('done');
    console.log('‚úÖ ÂèåÂêëÂêåÊ≠•ÂÆåÊàêÔºåÂ∫îÁî®Â∑≤ÂáÜÂ§áÂ∞±Áª™');
  }
}

export function updateSyncStatus(newStatus: SyncStatus, message?: string) {
  // Guard against SSR
  if (typeof window === 'undefined' || typeof localStorage === 'undefined') {
    return;
  }
  console.log(`Sync status: ${newStatus} - ${message || ''}`)
  localStorage.setItem('syncStatus', JSON.stringify([newStatus, message]))
  window.dispatchEvent(
    new StorageEvent('storage', {
      key: 'syncStatus',
      newValue: JSON.stringify([newStatus, message]),
    })
  )
}

export function useSyncStatus(): [SyncStatus, string | undefined] {
  const [syncStatus, setSyncStatus] = useState<[SyncStatus, string | undefined]>(['initial-sync', 'Starting sync...']);

  useEffect(() => {
    const getStatus = (): [SyncStatus, string | undefined] => {
      // This will only run on the client, where localStorage is available.
      const currentSyncStatusJson = localStorage.getItem('syncStatus');
      return currentSyncStatusJson ? JSON.parse(currentSyncStatusJson) : ['initial-sync', 'Starting sync...'];
    };
    
    setSyncStatus(getStatus());

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'syncStatus' && e.newValue) {
        setSyncStatus(JSON.parse(e.newValue));
      }
    };

    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, []);

  return syncStatus;
}

let initialSyncDone = false;
export function waitForInitialSyncDone() {
  return new Promise<void>((resolve) => {
    if (initialSyncDone) {
      resolve();
      return;
    }
    // Guard against SSR
    if (typeof window === 'undefined') {
      return;
    }
    const checkStatus = () => {
        const currentSyncStatusJson = localStorage.getItem('syncStatus');
        const [currentStatus] = currentSyncStatusJson ? JSON.parse(currentSyncStatusJson) : ['initial-sync'];
        if (currentStatus === 'done') {
            initialSyncDone = true;
            resolve();
            return true;
        }
        return false;
    };
    if (checkStatus()) return;

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'syncStatus' && e.newValue) {
        if (checkStatus()) {
          window.removeEventListener('storage', handleStorageChange);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
  });
}