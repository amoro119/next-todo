// components/goals/AssociateTaskModal.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import type { Todo } from "../../lib/types";
import { useDebounce } from "../../lib/hooks/useDebounce";
import { searchTodos, type SearchResult } from "../../lib/search/searchService";
import {
  SearchHistoryManager,
  SearchHighlighter,
} from "../../lib/search/searchUtils";
import { RecurringTaskGenerator } from "../../lib/recurring/RecurringTaskGenerator";
import Image from "next/image";
import React from "react";

interface AssociateTaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  onAssociateTasks: (taskIds: string[], goalId: string) => void;
  goalId: string;
  existingTaskIds: string[]; // Áî®‰∫é‰ªéÊêúÁ¥¢‰∏≠ÊéíÈô§Â∑≤ÂÖ≥ËÅîÁöÑ‰ªªÂä°
  refreshTrigger?: number; // Áî®‰∫éËß¶ÂèëÊêúÁ¥¢ÁªìÊûúÂà∑Êñ∞
}

interface AssociateTaskModalState {
  searchQuery: string;
  searchResults: Todo[];
  selectedTaskIds: string[]; // Áî®‰∫éË∑üË∏™ÈÄâÂÆöÁöÑ‰ªªÂä°
  isLoading: boolean;
  isVisible: boolean;
  searchError: string | null;
  lastSearchTime: number;
}

// Helper function for date formatting
const utcToLocalDateString = (utcDate: string | null | undefined): string => {
  if (!utcDate) return "";
  try {
    const date = new Date(utcDate);
    if (isNaN(date.getTime())) {
      const dateOnlyMatch = utcDate.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (dateOnlyMatch) return utcDate;
      return "";
    }
    const formatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: "Asia/Shanghai",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    });
    return formatter.format(date);
  } catch (e) {
    console.error("Error formatting date:", utcDate, e);
    return "";
  }
};

// SearchTodoItem component for displaying individual search results with multi-select
interface SearchTodoItemProps {
  todo: Todo;
  isSelected: boolean; // Êñ∞Â¢ûÂ±ûÊÄßÔºåË°®Á§∫ÊòØÂê¶Ë¢´ÈÄâ‰∏≠
  onToggleSelect: (todoId: string) => void; // Êñ∞Â¢ûÂ±ûÊÄßÔºåÂ§ÑÁêÜÈÄâÊã©ÂàáÊç¢
  searchQuery: string;
  index: number;
}

const SearchTodoItem = React.memo(function SearchTodoItem({
  todo,
  isSelected,
  onToggleSelect,
  searchQuery,
  index,
}: SearchTodoItemProps) {
  // Â§ÑÁêÜÈÄâÊã©ÂàáÊç¢
  const handleToggleSelect = () => {
    onToggleSelect(todo.id);
  };

  // Highlight search terms in text
  const highlightText = (text: string) => {
    if (!searchQuery.trim()) return text;
    return SearchHighlighter.highlight(text, searchQuery, "search-highlight");
  };

  return (
    <div
      className={`search-todo-item ${todo.completed ? "completed" : ""} ${
        todo.deleted ? "deleted" : ""
      } ${isSelected ? "selected" : ""}`} // Ê∑ªÂä† selected Á±ª
      onClick={handleToggleSelect} // ÁÇπÂáªÊï¥Ë°åÂàáÊç¢ÈÄâÊã©
      style={{ animationDelay: `${index * 50}ms` }}
    >
      <div
        className={`search-todo-content ${todo.completed ? "completed" : ""}`}
      >
        {/* Â§çÈÄâÊ°Ü */}
        <div className={`search-todo-checkbox ${isSelected ? "checked" : ""}`}>
          {isSelected && (
            <span className="search-todo-checkbox-check">‚úì</span>
          )}
        </div>

        {/* List name badge */}
        {todo.list_name && (
          <span className="search-todo-list-name">[{todo.list_name}] </span>
        )}

        {/* Recurring task badge - unified for both original and instances */}
        {RecurringTaskGenerator.isRecurringTask(todo) && (
          <span
            className="recurring-badge"
            title={RecurringTaskGenerator.getTaskRecurrenceDescription(todo)}
          >
            üîÑ
          </span>
        )}

        {/* Todo title with highlighting */}
        <span
          className={`search-todo-title ${todo.completed ? "completed" : ""}`}
          dangerouslySetInnerHTML={{ __html: highlightText(todo.title) }}
        />

        {/* Next due date for recurring tasks */}
        {RecurringTaskGenerator.isRecurringTask(todo) &&
          todo.next_due_date &&
          !todo.deleted && (
            <span className="search-todo-next-due" title="‰∏ãÊ¨°Âà∞ÊúüÊó∂Èó¥">
              ‰∏ãÊ¨°: {utcToLocalDateString(todo.next_due_date)}
            </span>
          )}

        {/* Due date */}
        {todo.due_date && !todo.deleted && (
          <span className="search-todo-due-date">
            {utcToLocalDateString(todo.due_date)}
          </span>
        )}
      </div>
    </div>
  );
});

// Memoized search results list for better performance
interface SearchResultsListProps {
  searchResults: Todo[];
  selectedTaskIds: string[];
  onToggleSelect: (todoId: string) => void;
  searchQuery: string;
}

const SearchResultsList = React.memo(function SearchResultsList({
  searchResults,
  selectedTaskIds,
  onToggleSelect,
  searchQuery,
}: SearchResultsListProps) {
  return (
    <>
      {searchResults.map((todo, index) => (
        <SearchTodoItem
          key={todo.id}
          todo={todo}
          isSelected={selectedTaskIds.includes(todo.id)}
          onToggleSelect={onToggleSelect}
          searchQuery={searchQuery}
          index={index}
        />
      ))}
    </>
  );
});

export default function AssociateTaskModal({
  isOpen,
  onClose,
  onAssociateTasks,
  goalId,
  existingTaskIds,
  refreshTrigger,
}: AssociateTaskModalProps) {
  const [state, setState] = useState<AssociateTaskModalState>({
    searchQuery: "",
    searchResults: [],
    selectedTaskIds: [], // ÂàùÂßãÂåñ‰∏∫Á©∫Êï∞ÁªÑ
    isLoading: false,
    isVisible: false,
    searchError: null,
    lastSearchTime: 0,
  });

  const modalRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);
  const searchAbortController = useRef<AbortController | null>(null);

  // ‰ΩøÁî®Èò≤ÊäñÂ§ÑÁêÜÊêúÁ¥¢Êü•ËØ¢
  const debouncedSearchQuery = useDebounce(state.searchQuery, 300);

  // Handle modal visibility and focus management
  useEffect(() => {
    if (isOpen) {
      // Store the previously focused element
      previousActiveElement.current = document.activeElement as HTMLElement;

      // Set modal as visible
      setState((prev) => ({ ...prev, isVisible: true }));

      // Focus the search input after a brief delay to ensure modal is rendered
      setTimeout(() => {
        searchInputRef.current?.focus();
      }, 100);

      // Prevent background scrolling
      document.body.style.overflow = "hidden";
    } else {
      // Reset state when closing
      setState((prev) => ({
        ...prev,
        isVisible: false,
        searchQuery: "",
        searchResults: [],
        selectedTaskIds: [], // ÈáçÁΩÆÈÄâÊã©
        isLoading: false,
        searchError: null,
        lastSearchTime: 0,
      }));

      // ÂèñÊ∂àÊ≠£Âú®ËøõË°åÁöÑÊêúÁ¥¢
      if (searchAbortController.current) {
        searchAbortController.current.abort();
        searchAbortController.current = null;
      }

      // Restore background scrolling
      document.body.style.overflow = "";

      // Restore focus to previously focused element
      if (previousActiveElement.current) {
        previousActiveElement.current.focus();
      }
    }

    // Cleanup on unmount
    return () => {
      document.body.style.overflow = "";
    };
  }, [isOpen]);

  // Handle keyboard events for modal
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        event.preventDefault();
        onClose();
      }

      // Handle Ctrl/Cmd+K to close modal when already open
      if ((event.ctrlKey || event.metaKey) && event.key === "k") {
        event.preventDefault();
        onClose();
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isOpen, onClose]);

  // Focus trap implementation
  useEffect(() => {
    if (!isOpen || !modalRef.current) return;

    const modal = modalRef.current;
    const focusableElements = modal.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[
      focusableElements.length - 1
    ] as HTMLElement;

    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          lastElement?.focus();
          e.preventDefault();
        }
      } else {
        if (document.activeElement === lastElement) {
          firstElement?.focus();
          e.preventDefault();
        }
      }
    };

    modal.addEventListener("keydown", handleTabKey);
    return () => modal.removeEventListener("keydown", handleTabKey);
  }, [isOpen]);

  // ÊâßË°åÊêúÁ¥¢ÁöÑÊïàÊûú
  useEffect(() => {
    if (!isOpen) return;

    const performSearch = async () => {
      const query = debouncedSearchQuery.trim();

      // Â¶ÇÊûúÊü•ËØ¢‰∏∫Á©∫ÔºåÊ∏ÖÁ©∫ÁªìÊûú
      if (!query) {
        setState((prev) => ({
          ...prev,
          searchResults: [],
          isLoading: false,
          searchError: null,
        }));
        return;
      }

      // ÂèñÊ∂à‰πãÂâçÁöÑÊêúÁ¥¢ËØ∑Ê±Ç
      if (searchAbortController.current) {
        searchAbortController.current.abort();
      }

      // ÂàõÂª∫Êñ∞ÁöÑ AbortController
      searchAbortController.current = new AbortController();
      const currentController = searchAbortController.current;

      try {
        // ËÆæÁΩÆÂä†ËΩΩÁä∂ÊÄÅ
        setState((prev) => ({
          ...prev,
          isLoading: true,
          searchError: null,
        }));

        const startTime = Date.now();

        // ÊâßË°åÊêúÁ¥¢
        const searchResult: SearchResult = await searchTodos(query, {
          fields: ["title", "content", "tags"],
          includeCompleted: true,
          includeDeleted: false,
          limit: 50,
        });

        // Ê£ÄÊü•ËØ∑Ê±ÇÊòØÂê¶Ë¢´ÂèñÊ∂à
        if (currentController.signal.aborted) {
          return;
        }

        // Ê∑ªÂä†Âà∞ÊêúÁ¥¢ÂéÜÂè≤
        SearchHistoryManager.addToHistory(query);

        // ËøáÊª§ÊéâÂ∑≤ÂÖ≥ËÅîÁöÑ‰ªªÂä°
        const filteredTodos = searchResult.todos.filter(
          (todo) => !existingTaskIds.includes(todo.id)
        );

        // Êõ¥Êñ∞ÊêúÁ¥¢ÁªìÊûú
        setState((prev) => ({
          ...prev,
          searchResults: filteredTodos,
          isLoading: false,
          searchError: null,
          lastSearchTime: Date.now() - startTime,
        }));
      } catch (error) {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂèñÊ∂àÈîôËØØ
        if (currentController.signal.aborted) {
          return;
        }

        console.error("Search failed:", error);

        setState((prev) => ({
          ...prev,
          searchResults: [],
          isLoading: false,
          searchError: "ÊêúÁ¥¢Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
          lastSearchTime: 0,
        }));
      }
    };

    performSearch();

    // Ê∏ÖÁêÜÂáΩÊï∞
    return () => {
      if (searchAbortController.current) {
        searchAbortController.current.abort();
        searchAbortController.current = null;
      }
    };
  }, [debouncedSearchQuery, isOpen]); // ÁßªÈô§ existingTaskIds ‰æùËµñ‰ª•ÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÈáçÊñ∞ÊêúÁ¥¢

  // ÁõëÂê¨refreshTriggerÂèòÂåñÔºåÈáçÊñ∞ÊâßË°åÊêúÁ¥¢
  useEffect(() => {
    if (!isOpen || refreshTrigger <= 0 || !state.searchQuery.trim()) return;

    const performRefreshSearch = async () => {
      const query = state.searchQuery.trim();

      // ÂèñÊ∂à‰πãÂâçÁöÑÊêúÁ¥¢ËØ∑Ê±Ç
      if (searchAbortController.current) {
        searchAbortController.current.abort();
      }

      // ÂàõÂª∫Êñ∞ÁöÑ AbortController
      searchAbortController.current = new AbortController();
      const currentController = searchAbortController.current;

      try {
        // ËÆæÁΩÆÂä†ËΩΩÁä∂ÊÄÅ
        setState((prev) => ({
          ...prev,
          isLoading: true,
          searchError: null,
        }));

        const startTime = Date.now();

        // ÊâßË°åÊêúÁ¥¢ÔºàÂº∫Âà∂Âà∑Êñ∞ÔºåË∑≥ËøáÁºìÂ≠òÔºâ
        const searchResult: SearchResult = await searchTodos(query, {
          fields: ["title", "content", "tags"],
          includeCompleted: true,
          includeDeleted: false,
          limit: 50,
          forceRefresh: true, // Âº∫Âà∂Âà∑Êñ∞
        });

        // Ê£ÄÊü•ËØ∑Ê±ÇÊòØÂê¶Ë¢´ÂèñÊ∂à
        if (currentController.signal.aborted) {
          return;
        }

        // ËøáÊª§ÊéâÂ∑≤ÂÖ≥ËÅîÁöÑ‰ªªÂä°
        const filteredTodos = searchResult.todos.filter(
          (todo) => !existingTaskIds.includes(todo.id)
        );

        // Êõ¥Êñ∞ÊêúÁ¥¢ÁªìÊûú
        setState((prev) => ({
          ...prev,
          searchResults: filteredTodos,
          isLoading: false,
          searchError: null,
          lastSearchTime: Date.now() - startTime,
        }));
      } catch (error) {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂèñÊ∂àÈîôËØØ
        if (currentController.signal.aborted) {
          return;
        }

        console.error("Refresh search failed:", error);

        setState((prev) => ({
          ...prev,
          isLoading: false,
          searchError: "Âà∑Êñ∞ÊêúÁ¥¢Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
        }));
      }
    };

    performRefreshSearch();
  }, [refreshTrigger, isOpen, state.searchQuery]); // ÁßªÈô§ existingTaskIds ‰æùËµñ‰ª•ÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÈáçÊñ∞ÊêúÁ¥¢

  // Handle search input changes
  const handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const query = event.target.value;
    setState((prev) => ({
      ...prev,
      searchQuery: query,
      searchError: null, // Ê∏ÖÈô§‰πãÂâçÁöÑÈîôËØØ
    }));
  };

  // Handle overlay click to close modal
  const handleOverlayClick = (event: React.MouseEvent<HTMLDivElement>) => {
    if (event.target === event.currentTarget) {
      onClose();
    }
  };

  // Handle close button click
  const handleCloseClick = () => {
    onClose();
  };

  // Â§ÑÁêÜ‰ªªÂä°ÈÄâÊã©ÂàáÊç¢
  const handleToggleSelect = (todoId: string) => {
    setState((prev) => {
      const isSelected = prev.selectedTaskIds.includes(todoId);
      let newSelectedTaskIds;
      
      if (isSelected) {
        // Â¶ÇÊûúÂ∑≤ÈÄâ‰∏≠ÔºåÂàô‰ªéÊï∞ÁªÑ‰∏≠ÁßªÈô§
        newSelectedTaskIds = prev.selectedTaskIds.filter(id => id !== todoId);
      } else {
        // Â¶ÇÊûúÊú™ÈÄâ‰∏≠ÔºåÂàôÊ∑ªÂä†Âà∞Êï∞ÁªÑ‰∏≠
        newSelectedTaskIds = [...prev.selectedTaskIds, todoId];
      }
      
      return {
        ...prev,
        selectedTaskIds: newSelectedTaskIds
      };
    });
  };

  // Â§ÑÁêÜÁ°ÆËÆ§ÊåâÈíÆÁÇπÂáª
  const handleConfirmClick = () => {
    if (state.selectedTaskIds.length > 0) {
      onAssociateTasks(state.selectedTaskIds, goalId);
      onClose();
    }
  };

  // Don't render anything if modal is not open
  if (!isOpen) {
    return null;
  }

  return (
    <div
      className="search-modal-overlay"
      onClick={handleOverlayClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby="search-modal-title"
    >
      <div
        ref={modalRef}
        className="search-modal-content"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Modal Header */}
        <div className="search-modal-header">
          <h2 id="search-modal-title" className="search-modal-title">
            ÂÖ≥ËÅî‰ªªÂä°
          </h2>
          <button
            className="search-modal-close"
            onClick={handleCloseClick}
            aria-label="ÂÖ≥Èó≠ÊêúÁ¥¢"
          >
            √ó
          </button>
        </div>

        {/* Search Input */}
        <div className="search-input-container">
          <input
            ref={searchInputRef}
            type="text"
            className="search-input"
            placeholder="ÊêúÁ¥¢‰ªªÂä°Ê†áÈ¢ò„ÄÅÂÜÖÂÆπ„ÄÅÊ†áÁ≠æ..."
            value={state.searchQuery}
            onChange={handleSearchChange}
            autoComplete="off"
          />
        </div>

        {/* Search Results Container */}
        <div className="search-results-container">
          {/* Âä†ËΩΩÁä∂ÊÄÅ */}
          {state.isLoading && (
            <div className="search-loading">
              <div className="loading-spinner"></div>
              <span>ÊêúÁ¥¢‰∏≠...</span>
            </div>
          )}

          {/* ÊêúÁ¥¢ÈîôËØØÁä∂ÊÄÅ */}
          {!state.isLoading && state.searchError && (
            <div className="search-error">
              <p>{state.searchError}</p>
              <button
                className="search-retry-btn"
                onClick={() =>
                  setState((prev) => ({ ...prev, searchError: null }))
                }
              >
                ÈáçËØï
              </button>
            </div>
          )}

          {/* Êó†ÁªìÊûúÁä∂ÊÄÅ */}
          {!state.isLoading &&
            !state.searchError &&
            state.searchQuery &&
            state.searchResults.length === 0 && (
              <div className="search-no-results">
                <p>ÊöÇÊó†ÂåπÈÖç‰ªªÂä°</p>
                <p className="search-no-results-hint">
                  Â∞ùËØï‰ΩøÁî®‰∏çÂêåÁöÑÂÖ≥ÈîÆËØçÊàñÊ£ÄÊü•ÊãºÂÜô
                </p>
              </div>
            )}

          {/* Á©∫Áä∂ÊÄÅ */}
          {!state.isLoading && !state.searchError && !state.searchQuery && (
            <div className="search-empty-state">
              <p>ÂºÄÂßãËæìÂÖ•‰ª•ÊêúÁ¥¢‰ªªÂä°</p>
              <p className="search-empty-hint">ÂèØ‰ª•ÊêúÁ¥¢‰ªªÂä°Ê†áÈ¢ò„ÄÅÂÜÖÂÆπ„ÄÅÊ†áÁ≠æ</p>
            </div>
          )}

          {/* ÊêúÁ¥¢ÁªìÊûú */}
          {!state.isLoading &&
            !state.searchError &&
            state.searchResults.length > 0 && (
              <div className="search-results">
                <div className="search-results-header">
                  <span className="search-results-count">
                    ÊâæÂà∞ {state.searchResults.length} ‰∏™ÂåπÈÖç‰ªªÂä°
                  </span>
                  {state.lastSearchTime > 0 && (
                    <span className="search-results-time">
                      ({state.lastSearchTime}ms)
                    </span>
                  )}
                </div>

                <div className="search-results-list">
                  <div className="search-todo-list">
                    <SearchResultsList
                      searchResults={state.searchResults}
                      selectedTaskIds={state.selectedTaskIds}
                      onToggleSelect={handleToggleSelect}
                      searchQuery={state.searchQuery}
                    />
                  </div>
                </div>
              </div>
            )}
        </div>

        {/* Modal Footer with Confirm Button */}
        <div className="modal-footer">
          <button
            className="btn-small confirm"
            onClick={handleConfirmClick}
            disabled={state.selectedTaskIds.length === 0}
          >
            Á°ÆËÆ§ÂÖ≥ËÅî ({state.selectedTaskIds.length})
          </button>
        </div>
      </div>
    </div>
  );
}